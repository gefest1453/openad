!
!  norma.f90
!
!  Free-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  04/05/2011 12:39:29
!
module norma0
#ifdef __PGI
  use ieee_arithmetic 

#endif
!use ieee_arithmetic
private norma3,norma1,norma116,norma216,norma316
private norma2,scalarp2,scalarp3,scalarp,scalarp216,scalarp316,scalarp16
interface norma
module procedure norma1,norma2,norma3 ,norma116,norma216,norma316
end interface
interface norma_INF
module procedure norma2_INF,norma3_INF
end interface

interface svertka
module procedure scalarp2,scalarp3,scalarp,scalarp216,scalarp316,scalarp16
end interface
interface operator (.x.)
    module procedure scalarp,scalarp2,scalarp3,scalarp216,scalarp316,scalarp16
end interface
INTERFACE MY_IS_NAN
MODULE PROCEDURE  my_is_nan_d,my_is_nan_Q,MY_IS_NAN_R
END INTERFACE
interface ddot
module procedure ddot2,ddot1
end interface
private my_is_nan_d,my_is_nan_q,MY_IS_NAN_R
    contains

        
       function ddot1(n,dx,incx,dy,incy) result(ddot)
!
!     forms the dot product of two vectors.
!     uses unrolled loops for increments equal to one.
!     jack dongarra, linpack, 3/11/78.
!
      double precision dx(:),dy(:),dtemp,ddot
      integer i,incx,incy,ix,iy,m,mp1,n
!
      ddot = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
!
!        code for unequal increments or equal increments
!          not equal to 1
!
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      ddot = dtemp
      return
!
!        code for both increments equal to 1
!
!
!        clean-up loop
!
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +  dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue
   60 ddot = dtemp
      return
      end function
      
        
     function ddot2(n,dx,incx,dy,incy) result(ddot)
!
!     forms the dot product of two vectors.
!     uses unrolled loops for increments equal to one.
!     jack dongarra, linpack, 3/11/78.
!
     real*16 dx(:),dy(:),dtemp,ddot
      integer i,incx,incy,ix,iy,m,mp1,n
!
      ddot = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
!
!        code for unequal increments or equal increments
!          not equal to 1
!
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      ddot = dtemp
      return
!
!        code for both increments equal to 1
!
!
!        clean-up loop
!
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +  dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue
   60 ddot = dtemp
      return
      end function
      
PURE INTEGER FUNCTION DELT(I,J)
INTEGER,INTENT(IN)::I,J
IF (I.EQ.J) THEN
DELT=1
ELSE
DELT=0
ENDIF
end function
PURE REAL*16  FUNCTION NORMA316(a)
REAL*16,INTENT(IN)::A(:,:,:)
norma316=sqrt(scalarp316(a,a))
END FUNCTION
PURE REAL*8  FUNCTION NORMA3(a)
REAL*8,INTENT(IN)::A(:,:,:)
norma3=sqrt(scalarp3(a,a))
END FUNCTION


PURE REAL*8  FUNCTION SCALARP3(A,B)
REAL*8,INTENT(IN)::a(:,:,:),b(:,:,:)
real*16::s
integer i,j,k
s=0
do k=lbound(a,dim=3),ubound(a,dim=3)
do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
!if (ieee_is_nan(a(i,j,k)).or.(ieee_is_nan(b(i,j,k)))) then
!stop
!endif
s=s+a(i,j,k)*b(i,j,k)

!WRITE(*,*) I,J,K,S

enddo
enddo
enddo

SCALARp3=s
END FUNCTION


PURE REAL*16  FUNCTION SCALARP316(A,B)
REAL*16,INTENT(IN)::a(:,:,:),b(:,:,:)
real*16::s
integer i,j,k
s=0
do k=lbound(a,dim=3),ubound(a,dim=3)
do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
!if (ieee_is_nan(a(i,j,k)).or.(ieee_is_nan(b(i,j,k)))) then
!stop
!endif
s=s+a(i,j,k)*b(i,j,k)

!WRITE(*,*) I,J,K,S

enddo
enddo
enddo

SCALARp316=s
END FUNCTION

PURE REAL*8  FUNCTION NORMA2(a)
REAL*8,INTENT(IN)::A(:,:)
norma2=sqrt(scalarp2(a,a))
END FUNCTION
pure REAL*8  FUNCTION SCALARP2(A,B)
REAL*8,INTENT(IN)::a(:,:),b(:,:)
REAL*16::s
integer i,j,k
s=0
!do k=lbound(a,dim=3),ubound(a,dim=3)
do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
!if (ieee_is_nan(a(i,j)).or.(ieee_is_nan(b(i,j)))) then
!stop
!endif
s=s+a(i,j)*b(i,j)
!if (ieee_is_nan(s)) then
!write(*,*) i,j,k
!write (*,*) "v_speed\n"
!stop
!endif
enddo
enddo
!enddo

SCALARp2=s
END FUNCTION


PURE REAL*16  FUNCTION NORMA216(a)
REAL*16,INTENT(IN)::A(:,:)
norma216=sqrt(scalarp216(a,a))
END FUNCTION
pure REAL*16  FUNCTION SCALARP216(A,B)
REAL*16,INTENT(IN)::a(:,:),b(:,:)
REAL*16::s
integer i,j,k
s=0
!do k=lbound(a,dim=3),ubound(a,dim=3)
do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
!if (ieee_is_nan(a(i,j)).or.(ieee_is_nan(b(i,j)))) then
!stop
!endif
s=s+a(i,j)*b(i,j)
!if (ieee_is_nan(s)) then
!write(*,*) i,j,k
!write (*,*) "v_speed\n"
!stop
!endif
enddo
enddo
!enddo

SCALARp216=s
END FUNCTION

pure REAL*8  FUNCTION SCALARP(A,B)
REAL*8,INTENT(IN)::a(:),b(:)
REAL*16::s
integer i,j,k
s=0
!do k=lbound(a,dim=3),ubound(a,dim=3)
!do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
s=s+a(i)*b(i)
enddo
!enddo
!enddo
SCALARp=s
END FUNCTION
pure real*8 function norma1(a)
REAL*8,INTENT(IN)::a(:)
norma1=sqrt(scalarp(a,a))
end function

pure REAL*16  FUNCTION SCALARP16(A,B)
REAL*16,INTENT(IN)::a(:),b(:)
REAL*16::s
integer i,j,k
s=0
!do k=lbound(a,dim=3),ubound(a,dim=3)
!do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
s=s+a(i)*b(i)
enddo
!enddo
!enddo
SCALARp16=s
END FUNCTION
pure real*16 function norma116(a)
REAL*16,INTENT(IN)::a(:)
norma116=sqrt(scalarp16(a,a))
end function
PURE REAL*8  FUNCTION NORMA3_INF(A)
REAL*8,INTENT(IN)::a(:,:,:)
REAL*16::s
integer i,j,k
s=0
do k=lbound(a,dim=3),ubound(a,dim=3)
do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
s=MAX(s,ABS(A(I,J,K)))

enddo
enddo
enddo

NORMA3_INF=s
END FUNCTION



PURE REAL*8  FUNCTION NORMA2_INF(A)
REAL*8,INTENT(IN)::a(:,:)
REAL*8::s
integer i,j,k
s=0

do j=lbound(a,dim=2),ubound(a,dim=2)
do i=lbound(a,dim=1),ubound(a,dim=1)
s=MAX(s,ABS(A(I,J)))

enddo
enddo


NORMA2_INF=s
END FUNCTION



logical function my_is_nan_R(x)
real,intent(in)::x
#ifdef __PGI
my_is_nan_r= ieee_is_nan(x)
#else
my_is_nan_r= isnan(x)
#endif
return
end function

logical function my_is_nan_d(x)
double precision,intent(in)::x
#ifdef __PGI
my_is_nan_d= ieee_is_nan(x)
#else
my_is_nan_d= isnan(x)
#endif
return
end function
logical function my_is_nan_Q(x)
REAL*16,intent(in)::x
#ifdef __PGI
my_is_nan_Q= ieee_is_nan(x)
#else
my_is_nan_Q= isnan(x)
#endif
return
end function
end module norma0
