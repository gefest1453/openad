!
!  norma.f90
!
!  Free-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  04/05/2011 12:39:29
!
module norma0
#ifdef __PGI
  use ieee_arithmetic 

#endif
#ifdef __ABSOFT
  use ieee_arithmetic 

#endif

  !use ieee_arithmetic
  private norma3,norma1,norma116,norma216,norma316
  private norma2,scalarp2,scalarp3,scalarp,scalarp216,scalarp316,scalarp16
  interface norma
     module procedure norma1,norma2,norma3 ,norma116,norma216,norma316
  end interface norma
  interface norma_INF
     module procedure norma2_INF,norma3_INF
  end interface norma_INF

  interface svertka
     module procedure scalarp2,scalarp3,scalarp,scalarp216,scalarp316,scalarp16
  end interface svertka
  interface operator (.x.)
     module procedure scalarp,scalarp2,scalarp3,scalarp216,scalarp316,scalarp16
  end interface operator (.x.)
  INTERFACE MY_IS_NAN
     MODULE PROCEDURE  my_is_nan_d,my_is_nan_Q,MY_IS_NAN_R
  END INTERFACE MY_IS_NAN
  interface ddot
     module procedure ddot2,ddot1
  end interface ddot
  private my_is_nan_d,my_is_nan_q,MY_IS_NAN_R
contains


  function ddot1(n,dx,incx,dy,incy) result(ddot)
    !
    !     forms the dot product of two vectors.
    !     uses unrolled loops for increments equal to one.
    !     jack dongarra, linpack, 3/11/78.
    !
    double precision dx(:),dy(:),dtemp,ddot
    integer i,incx,incy,ix,iy,m,mp1,n
    !
    ddot = 0.0d0
    dtemp = 0.0d0
    if(n.le.0)return
    if(incx.eq.1.and.incy.eq.1)go to 20
    !
    !        code for unequal increments or equal increments
    !          not equal to 1
    !
    ix = 1
    iy = 1
    if(incx.lt.0)ix = (-n+1)*incx + 1
    if(incy.lt.0)iy = (-n+1)*incy + 1
    do 10 i = 1,n
       dtemp = dtemp + dx(ix)*dy(iy)
       ix = ix + incx
       iy = iy + incy
10     continue
       ddot = dtemp
       return
       !
       !        code for both increments equal to 1
       !
       !
       !        clean-up loop
       !
20     m = mod(n,5)
       if( m .eq. 0 ) go to 40
       do 30 i = 1,m
          dtemp = dtemp + dx(i)*dy(i)
30        continue
          if( n .lt. 5 ) go to 60
40        mp1 = m + 1
          do 50 i = mp1,n,5
             dtemp = dtemp + dx(i)*dy(i) +&
                  & dx(i + 1)*dy(i + 1) +  dx(i + 2)*dy(i + 2)&
                  & + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
50           continue
60           ddot = dtemp
             return
           end function


           function ddot2(n,dx,incx,dy,incy) result(ddot)
             !
             !     forms the dot product of two vectors.
             !     uses unrolled loops for increments equal to one.
             !     jack dongarra, linpack, 3/11/78.
             !
             real*16 dx(:),dy(:),dtemp,ddot
             integer i,incx,incy,ix,iy,m,mp1,n
             !
             ddot = 0.0d0
             dtemp = 0.0d0
             if(n.le.0)return
             if(incx.eq.1.and.incy.eq.1)go to 20
             !
             !        code for unequal increments or equal increments
             !          not equal to 1
             !
             ix = 1
             iy = 1
             if(incx.lt.0)ix = (-n+1)*incx + 1
             if(incy.lt.0)iy = (-n+1)*incy + 1
             do 10 i = 1,n
                dtemp = dtemp + dx(ix)*dy(iy)
                ix = ix + incx
                iy = iy + incy
10              continue
                ddot = dtemp
                return
                !
                !        code for both increments equal to 1
                !
                !
                !        clean-up loop
                !
20              m = mod(n,5)
                if( m .eq. 0 ) go to 40
                do 30 i = 1,m
                   dtemp = dtemp + dx(i)*dy(i)
30                 continue
                   if( n .lt. 5 ) go to 60
40                 mp1 = m + 1
                   do 50 i = mp1,n,5
                      dtemp = dtemp + dx(i)*dy(i) + &
                           &dx(i + 1)*dy(i + 1)&
                           & +  dx(i + 2)*dy(i + 2) &
                           &+ dx(i + 3)*dy(i + 3) &
                           &+ dx(i + 4)*dy(i + 4)
50                    continue
60                    ddot = dtemp
                      return
                    end function

                    PURE INTEGER FUNCTION DELT(I,J)
                      INTEGER,INTENT(IN)::I,J
                      IF (I.EQ.J) THEN
                         DELT=1
                      ELSE
                         DELT=0
                      ENDIF
                    end function DELT
                    PURE REAL*16  FUNCTION NORMA316(a)
                      REAL*16,INTENT(IN)::A(:,:,:)
                      norma316=sqrt(scalarp316(a,a))
                    END FUNCTION NORMA316
                    PURE REAL*8  FUNCTION NORMA3(a)
                      REAL*8,INTENT(IN)::A(:,:,:)
                      norma3=sqrt(scalarp3(a,a))
                    END FUNCTION NORMA3


                    PURE REAL*8  FUNCTION SCALARP3(A,B)
                      REAL*8,INTENT(IN)::a(:,:,:),b(:,:,:)
                      real*16::s
                      integer i,j,k
                      s=0
                      do k=lbound(a,dim=3),ubound(a,dim=3)
                         do j=lbound(a,dim=2),ubound(a,dim=2)
                            do i=lbound(a,dim=1),ubound(a,dim=1)
                               !if (ieee_is_nan(a(i,j,k)).or.(ieee_is_nan(b(i,j,k)))) then
                               !stop
                               !endif
                               s=s+a(i,j,k)*b(i,j,k)

                               !WRITE(*,*) I,J,K,S

                            enddo
                         enddo
                      enddo

                      SCALARp3=s
                    END FUNCTION SCALARP3


                    PURE REAL*16  FUNCTION SCALARP316(A,B)
                      REAL*16,INTENT(IN)::a(:,:,:),b(:,:,:)
                      real*16::s
                      integer i,j,k
                      s=0
                      do k=lbound(a,dim=3),ubound(a,dim=3)
                         do j=lbound(a,dim=2),ubound(a,dim=2)
                            do i=lbound(a,dim=1),ubound(a,dim=1)
                               !if (ieee_is_nan(a(i,j,k)).or.(ieee_is_nan(b(i,j,k)))) then
                               !stop
                               !endif
                               s=s+a(i,j,k)*b(i,j,k)

                               !WRITE(*,*) I,J,K,S

                            enddo
                         enddo
                      enddo

                      SCALARp316=s
                    END FUNCTION SCALARP316

                    PURE REAL*8  FUNCTION NORMA2(a)
                      REAL*8,INTENT(IN)::A(:,:)
                      norma2=sqrt(scalarp2(a,a))
                    END FUNCTION NORMA2
                    pure REAL*8  FUNCTION SCALARP2(A,B)
                      REAL*8,INTENT(IN)::a(:,:),b(:,:)
                      REAL*16::s
                      integer i,j,k
                      s=0
                      !do k=lbound(a,dim=3),ubound(a,dim=3)
                      do j=lbound(a,dim=2),ubound(a,dim=2)
                         do i=lbound(a,dim=1),ubound(a,dim=1)
                            !if (ieee_is_nan(a(i,j)).or.(ieee_is_nan(b(i,j)))) then
                            !stop
                            !endif
                            s=s+a(i,j)*b(i,j)
                            !if (ieee_is_nan(s)) then
                            !write(*,*) i,j,k
                            !write (*,*) "v_speed\n"
                            !stop
                            !endif
                         enddo
                      enddo
                      !enddo

                      SCALARp2=s
                    END FUNCTION SCALARP2


                    PURE REAL*16  FUNCTION NORMA216(a)
                      REAL*16,INTENT(IN)::A(:,:)
                      norma216=sqrt(scalarp216(a,a))
                    END FUNCTION NORMA216
                    pure REAL*16  FUNCTION SCALARP216(A,B)
                      REAL*16,INTENT(IN)::a(:,:),b(:,:)
                      REAL*16::s
                      integer i,j,k
                      s=0
                      !do k=lbound(a,dim=3),ubound(a,dim=3)
                      do j=lbound(a,dim=2),ubound(a,dim=2)
                         do i=lbound(a,dim=1),ubound(a,dim=1)
                            !if (ieee_is_nan(a(i,j)).or.(ieee_is_nan(b(i,j)))) then
                            !stop
                            !endif
                            s=s+a(i,j)*b(i,j)
                            !if (ieee_is_nan(s)) then
                            !write(*,*) i,j,k
                            !write (*,*) "v_speed\n"
                            !stop
                            !endif
                         enddo
                      enddo
                      !enddo

                      SCALARp216=s
                    END FUNCTION SCALARP216

                    pure REAL*8  FUNCTION SCALARP(A,B)
                      REAL*8,INTENT(IN)::a(:),b(:)
                      REAL*16::s
                      integer i,j,k
                      s=0
                      !do k=lbound(a,dim=3),ubound(a,dim=3)
                      !do j=lbound(a,dim=2),ubound(a,dim=2)
                      do i=lbound(a,dim=1),ubound(a,dim=1)
                         s=s+a(i)*b(i)
                      enddo
                      !enddo
                      !enddo
                      SCALARp=s
                    END FUNCTION SCALARP
                    pure real*8 function norma1(a)
                      REAL*8,INTENT(IN)::a(:)
                      norma1=sqrt(scalarp(a,a))
                    end function norma1

                    pure REAL*16  FUNCTION SCALARP16(A,B)
                      REAL*16,INTENT(IN)::a(:),b(:)
                      REAL*16::s
                      integer i,j,k
                      s=0
                      !do k=lbound(a,dim=3),ubound(a,dim=3)
                      !do j=lbound(a,dim=2),ubound(a,dim=2)
                      do i=lbound(a,dim=1),ubound(a,dim=1)
                         s=s+a(i)*b(i)
                      enddo
                      !enddo
                      !enddo
                      SCALARp16=s
                    END FUNCTION SCALARP16
                    pure real*16 function norma116(a)
                      REAL*16,INTENT(IN)::a(:)
                      norma116=sqrt(scalarp16(a,a))
                    end function norma116
                    PURE REAL*8  FUNCTION NORMA3_INF(A)
                      REAL*8,INTENT(IN)::a(:,:,:)
                      REAL*8::s
                      integer i,j,k
                      s=0
                      do k=lbound(a,dim=3),ubound(a,dim=3)
                         do j=lbound(a,dim=2),ubound(a,dim=2)
                            do i=lbound(a,dim=1),ubound(a,dim=1)
                               s=MAX(s,ABS(A(I,J,K)))

                            enddo
                         enddo
                      enddo

                      NORMA3_INF=s
                    END FUNCTION NORMA3_INF



                    PURE REAL*8  FUNCTION NORMA2_INF(A)
                      REAL*8,INTENT(IN)::a(:,:)
                      REAL*8::s
                      integer i,j,k
                      s=0

                      do j=lbound(a,dim=2),ubound(a,dim=2)
                         do i=lbound(a,dim=1),ubound(a,dim=1)
                            s=MAX(s,ABS(A(I,J)))

                         enddo
                      enddo


                      NORMA2_INF=s
                    END FUNCTION NORMA2_INF



                    logical function my_is_nan_R(x)
#ifdef __ABSOFT
                      USE IEEE_ARITHMETIC

#endif
                      real*4,intent(in)::x
#ifdef __PGI
                      my_is_nan_r= ieee_is_nan(x)
#else
#ifdef __ABSOFT
                      my_is_nan_r= .false.
#else
                      my_is_nan_r= isnan(x)
#endif
#endif
                      return
                    end function my_is_nan_R

                    logical function my_is_nan_d(x)
#ifdef __ABSOFT
                      USE IEEE_ARITHMETIC

#endif
                      double precision,intent(in)::x
#ifdef __PGI
                      my_is_nan_d= ieee_is_nan(x)
#else
#ifdef __ABSOFT
                      my_is_nan_d= .false.
#else
                      my_is_nan_d= isnan(x)
#endif
#endif
                      return
                    end function my_is_nan_d
                    logical function my_is_nan_Q(x)
#ifdef __ABSOFT
                      USE IEEE_ARITHMETIC

#endif
                      REAL*16,intent(in)::x
#ifdef __PGI
                      my_is_nan_Q= ieee_is_nan(x)
#else
#ifdef __ABSOFT
                      my_is_nan_q= .false.
#else
                      my_is_nan_Q= isnan(x)
#endif
#endif
                      return
                    end function my_is_nan_Q
                  end module norma0
